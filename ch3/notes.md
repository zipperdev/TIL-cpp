## 챕터3 - 표현식과 문장

표현식은 특정 값을 가진 엔티티이다.  
메모리를 조작할 수 있으며 이를 부가 효과라고 한다.  
표현식은 각 우선 순위와 결합 방향 순서에 따라 연산된다.  
다음은 우선 순위 내림차순으로 나열한 표현식들이다.

- **기본 표현식**  
  연산자가 없는 표현식이다.  
  리터럴, 이름, 괄호가 해당한다.
- **단항 표현식**  
  하나의 피연산자에 `+`, `-` 등의 연산자를 사용한다. 결합 방향이 역이다.  
  양수, 음수 표현식, `sizeof`가 해당한다.
- **곱셈 표현식**  
  양 옆에 피연산자가 있는 이항 표현식이다.  
  `*`, `/`, `%`가 해당한다.
- **덧셈 표현식**  
  양 옆에 피연산자가 있는 이항 표현식이다.
  `+`, `-`이 해당한다.
- **할당 표현식**  
  부가 작용이 발생한다. 결합 방향이 역이다.  
  단순 할당, 복합 할당이 해당한다.  
  할당 연산자의 왼쪽에 놓인 엔티티를 lvalue, 오른쪽에 놓인 엔티티를 rvalue라고 한다.

---

표현식의 자료형은 `<typeinfo>` 헤더를 사용해 다음과 같이 알 수 있다.
```c++
#include <typeinfo>

typeid(표현식).name()
```

자료형 변환은 암묵적 또는 명시적으로 이루어진다.

암묵적 자료형 변환에는 암묵적 자료형 승격과 암묵적 자료형 변경이 있다.
- **암묵적 자료형 승격**  
  피연산자의 자료형이 연산자에 결합하지 않는 경우나, 맞는 연산자가 없는 경우 발생한다.
- **암묵적 자료형 변경**  
  두 피연산자의 자료형이 다를 때 발생한다.

명시적 자료형 변환 또는 캐스팅은 자료형을 원하는 형태로 강제적으로 변환하는 것이다.  
```c++
static_cast<자료형>(표현식)
```

---

자료형의 최대값 또는 최솟값을 넘어서는 값을 저장할 때 문제가 발생한다.  
각각을 **오버플로우**, **언더플로우**라고 한다.  
기능상 문제가 발생하지만 오류는 보통 발생하지 않는다.

정수에서 발생한 경우, 다시 돌아서 범위를 지킨다.  
부동 소수점에서 발생한 경우, 각각 양의 무한대와 음의 무한대로 수렴한다.

---

C++는 기본적으로 표준 형식으로 입출력이 이루어진다.  
이를 **조정자**를 사용해 그 형식을 바꿀 수 있다.  
조정자는 기본적으로 1회 지정하면 다른 곳에서도 계속 적용된다.

`<iomanip>` 헤더는 매개변수를 가지는 조정자를 제공한다.  
`setprecision(n)`은 필요할 때마다 적용해야 한다.

입력 조정자는 출력 조정자와 다르게 입력된 값을 그것으로 변환하는 것이 아니라, 입력을 그 형식으로 받는 것이다.

---

변수 선언은 단일 선언, 복수 선언, 초기화로 할 수 있다.
```c++
// 단일 선언
short foo;
double bar;

// 복수 선언
int a, b, c;
char ch1, ch2;

// 초기화
long baz = 0;
bool qux = true; 
```

초기화하지 않은 전역 변수는 기본값, 보통 0으로 초기화한다.  
초기화하지 않은 지역 변수는 해당 위치의 가비지 값을 갖는다.

문장 또는 구문의 예시로는 표현식 구문, null 구문, 복합 구문이 있다.  
표현식 구문은 표현식에 세미콜론을 붙인 문장이다.  
null 구문은 문법 등의 이유로 세미콜론만 사용한 문장이다.  
복합 구문은 중괄호로 묶은 문장이다.
